# Pickle

	Pickle是Python标准库的一部分，他是用Ｃ编写，可以序列化任意复杂的Python数据结构。
	支持原生类型：布尔， 整数， 浮点数， 复数， 字符串， 字节串对象， 字节数组， NoneＮＯｎｅ
	支持任何原生类型组成的列表， 元组， 字典， 集合, 以及它们的嵌套
	支持函数， 类， 类的实例
	它本身可扩展
	pickle模块 使用一个被称为“pickle协议”的东西序列化该数据结构。
    pickle 协议是Python特定的，没有任何跨语言兼容的保证。
    并非所有的Python数据结构都可以通过pickle模块序列化。
    除非你指定，pickle模块中的函数将使用最新版本的pickle协议。
    最新版本的pickle协议是二进制格式的。请确认使用二进制模式来打开你的pickle文件,否则当你写入的时候数据会被损坏。
    pickle.load()函数接受一个流对象, 从流中读取序列化后的数据，创建一个新的Python对象，
    在新的Python对象中重建被序列化的数据，然后返回新建的Python对象。
time 模块包含一个表示时间点(精确到1毫秒)的数据结构(time_struct)以及操作时间结构的函数。
    strptime()函数接受一个格式化过的字符串并将其转化成一个time_struct。这个字符串使用的是默认格式，但你可以通过格式化代码来控制它。
with 语句中来保证在你完成的时候文件自动被关闭。
序列化到一个内存中的bytes对象
    pickle.dumps()函数(注意函数名最后的's')执行和pickle.dump()函数相同的序列化。
    取代接受流对象并将序列化后的数据保存到磁盘文件，这个函数简单的返回序列化的数据。
    在pickle协议里面没有明确的版本标志。为了确定保存pickle文件时使用的协议版本，
    你需要查看序列化后的数据的标记(“opcodes”)并且使用硬编码的哪个版本的协议引入了哪些标记的知识(来确定版本号)。
    pickle.dis()函数正是这么干的，并且它在反汇编的输出的最后一行打印出结果。

# json
    同 pickle模块类似, json模块包含一些函数，可以序列化数据结构，
    保存序列化后的数据至磁盘，从磁盘上读取序列化后的数据，
    将数据反序列化成新的Pythone对象。但两者也有一些很重要的区别。 
    首先, json数据格式是基于文本的, 不是二进制的。
    第二，由于是文本格式, 存在空白(whitespaces)的问题。
        json 允许在值之间有任意数目的空白(空格, 跳格, 回车，换行)。空白是“无关紧要的”。
    第三, 字符编码的问题是长期存在的。json 用纯文本编码数据, 但是你知道, “不存在纯文本这种东西。” 
    json必须以Unicode 编码(UTF-32, UTF-16, 或者默认的, utf-8)方式存储
    
    笔记  JSON        Python 3
        object      dictionary
        array       list
        string      string
        integer     integer
        real number float
    *   true    True
    *   false   False
    *   null    None
    * 所有的 json 值都是大小写敏感的。
    json 有数组类型, json 模块将其映射到Python的列表, 但是它没有一个单独的类型对应 “冻结数组(frozen arrays)” (元组)。
    而且尽管 json 非常好的支持字符串，但是它没有对bytes 对象或字节数组的支持。
    json模块提供了编解码未知数据类型的扩展接口。
    
    json 并不区分元组和列表；它只有一个类似列表的数据类型，数组，
    并且json模块在序列化过程中会安静的将元组和列表两个都转换成json 数组。
    大多数情况下，你可以忽略元组和列表的区别，但是在使用json 模块时应记得有这么一回事。